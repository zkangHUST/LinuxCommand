# 0. 什么是信号
signal就是一条小消息，它通知进程系统中发生了某种类型的事件。常见的signal如下：

|ID|名称|默认行为|对应的事件|
|---|---|---|---|
|2|SIGINT|终止进程|用户按下Ctrl-C|
|9|SIGKILL|终止进程|Kill Program(不能覆盖也不能忽略)|
|11|SIGSEGV|终止进程|无效的内存引用(段错误)|
|14|SIGALRM|终止进程|来自alarm函数的定时器信号|
|17|SIGCHLD|忽略|子进程终止或暂停|

# 1. 信号术语

- 信号发送
内核通过更新目的进程上下文中的某个状态，发送(传递)一个信号给目的进程。发送信号的原因有两个：
  1. 内核检测到一个系统事件，比如除0错误会导致内核发送SIGFPE信号，子进程终止或停止会导致内核发送SIGCHLD给父进程。
  2. 另外一个进程调用了kill系统调用，显式的要求内核发送一个信号给指定进程。(在键盘上按ctrl c就是如此)

    一个进程可以自己给自己发信号
- 信号接收
当目的进程被内核强迫以某种方式对信号的发送做出响应时，它就接收了信号。进程对信号可以采用三种处理方式
  1. 忽略信号，啥也不干
  2. 终止进程
  3. 捕获这个信号，执行一个用户层的函数，这个函数称为信号处理函数。

- 待处理信号(Pending Signal)
一个发出而没有被接收的信号称为待处理信号，在任何时刻，一种类型最多只能有一个待处理信号(因为前面已经说过，发送信号是更新目的进程上下文中的某个状态，也就是将某个bit位置位， 如果一个bit位已经置位了， 那么不可能再次置位)。

- 阻塞信号
进程可以选择阻塞某个信号，当一个信号被阻塞后，它还可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这个信号的阻塞为止。

- Pending/Blocked Bits
内核在每个进程的上下文中维护了pending和blocked位向量(bit vector)。
Pending位向量表示pending信号的集合， 需要发送信号k的时候，内核会讲pending位向量中的bit k置位；当信号k被接收后，内核会将pending位向量中的bit k清零。
blocked位向量表示被block的信号集合，可以通过sigprocmask函数对blocked 位向量中的某个bit置位或清零。

# 2. 发送信号
发送信号的方式有四种：
## 1. 通过/bin/kill程序发送信号， 如：
```bash
> /bin/kill -9 15213        // 向pid为15213的进程发送9号信号(SIGKILL),这个进程不能被catch也不能被忽略
> /bin/kill -9 -15213        // 向pid进程组为15213的所有进程发送9号信号
```

## 2. 从键盘发送信号

从键盘上输入CTRL+C会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况下，这个信号会终止进程。类似的， 输入CTRL+Z会发送一个SIGTSTP信号，这个信号会暂停前台进程。

## 3.通过kill函数发送信号
```C
#include<signal.h>
int kill(pid_t pid, int sig);
```

|pid值|动作|
|---|---|
|>0|那么发送信号sig到pid值为pid的进程|
|<0|那么发送信号sig到进程组|pid|中的所有进程|
|=0|发送信号sig给调用进程所在进程组的每个进程，包括调用进程本身|

## 4.用alarm函数发送信号
进程可以通过alarm函数向它自己发送SIGALRM信号
```C
#include<unistd.h>
unsigned int alarm(unsigned int secs);
```
alarm函数安排内核在secs秒后发送SIGALRM信号给调用进程


